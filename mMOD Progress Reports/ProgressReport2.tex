\documentclass[letterpaper, 11pt]{article}
% \usepackage[utf8]{inputenc}
% \usepackage{sansmathfonts}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[margin=0.5in, head=40pt, top=1in, bottom=1in]{geometry} 
\usepackage{array}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amsthm,amssymb,amsfonts, fancyhdr, color, comment, graphicx, environ, mathtools}
\usepackage[dvipsnames]{xcolor}
\usepackage{mdframed}
\usepackage[shortlabels]{enumitem}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{siunitx}
% \usepackage{ stmaryrd }
\usepackage{ textcomp }
\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{multirow}
\usepackage{lastpage}
\usepackage{longtable}
\usepackage{gensymb}
\usepackage[version=4]{mhchem}
\usepackage{caption}
\usepackage{tikz}
\usepackage{physics}
\usepackage{sectsty}
\usepackage{float}

\captionsetup{justification=centering,format=hang,labelsep=period,font={footnotesize}, labelfont={rm}}

% \renewcommand*\familydefault{\sfdefault} 

% \usepackage{bm}
\newcommand{\vect}[1]{\boldsymbol{\mathbf{#1}}}

\definecolor{scarlet}{HTML}{CC0033}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,      
	urlcolor=blue,
}

\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}
\graphicspath{ {./figures/} }
\pagestyle{fancy}

\global\mdfdefinestyle{equationbox}{%
	linecolor=black,linewidth=0.5pt,%
	backgroundcolor=white
}


\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
%
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\usepackage{lmodern}
% \usepackage[math]{iwona}
\usepackage{breqn}
\usepackage{mdframed}
\usepackage[subnum]{cases}
\usepackage{pdfpages}
\usepackage{soul}
\usepackage{nicematrix}
\usepackage[ruled, linesnumbered]{algorithm2e}
\lhead{Rutgers University}
\rhead{ Anastasia Moreno \thepage \space of \pageref{LastPage}} 
\lfoot{}
\chead{}
\cfoot{Proprietary to the mMOD Group.}
% \usepackage[
%     backend=bibtex,
%     style=ieee,
% ]{biblatex}
% \addbibresource{./lib.bib}
\makeatletter
\DeclareRobustCommand{\vol}{\text{\volumedash}V}
\newcommand{\volumedash}{%
	\makebox[0pt][l]{%
		\ooalign{\hfil\hphantom{$\m@th V$}\hfil\cr\kern0.08em--\hfil\cr}%
	}%
}
\makeatother

\newcommand{\sgrav}{\ensuremath{\mathrm{SG}}}
\newcommand{\half}{\ensuremath{\frac{1}{2}}}
\newcommand{\tder}{\ensuremath{\frac{d}{dt}}}
\newcommand{\tsder}{\ensuremath{\frac{d^2}{dt^2}}}
\newcommand{\pde}[2]{\ensuremath{\frac{\partial#1}{\partial#2}}}
\newcommand{\ode}[2]{\ensuremath{\frac{d #1}{d #2}}}

\newcommand{\ihat}{\ensuremath{\vb{\hat{i}}}}
\newcommand{\jhat}{\ensuremath{\vb{\hat{j}}}}
\newcommand{\khat}{\ensuremath{\vb{\hat{k}}}}
\newcommand{\Ihat}{\ensuremath{\vb{\hat{I}}}}
\newcommand{\Jhat}{\ensuremath{\vb{\hat{J}}}}
\newcommand{\Khat}{\ensuremath{\vb{\hat{K}}}}
\newcommand{\qbarinf}{\ensuremath{\bar{q}_\infty}}
\newcommand{\qbar}{\ensuremath{\bar{q}}}
\newcommand{\rinf}{\ensuremath{\bar{\rho}_\infty}}
\newcommand{\meanchord}{\ensuremath{\bar{c}}}
\newcommand{\CMqc}{\ensuremath{C_{M_{c/4}}}}
\newcommand{\Cmqc}{\ensuremath{C_{m_{c/4}}}}
\newcommand{\CLa}{\ensuremath{C_{L_{\alpha}}}}
\newcommand{\Cla}{\ensuremath{C_{l_{\alpha}}}}
\newcommand{\CL}{\ensuremath{C_{L}}}
\newcommand{\Cl}{\ensuremath{C_{l}}}
\newcommand{\Mqc}{\ensuremath{M_{c/4}}}
\newcommand{\CD}{\ensuremath{C_{D}}}
\newcommand{\CDo}{\ensuremath{C_{D_0}}}
\newcommand{\CDI}{\ensuremath{C_{D,i}}}
\newcommand{\TSFC}{\ensuremath{\mathrm{TSFC}}}
\newcommand{\Vinf}{\ensuremath{V_{\infty}}}

\newcommand{\question}[1]{\colorbox{Cyan}{\texttt{Question #1}}}
\newcommand{\skewsym}[1]{\ensuremath{[\tilde{#1}]}}
\usepackage{matlab-prettifier}

\definecolor{backcolour}{rgb}{0.98,0.98,0.98}
\definecolor{darkgrey}{rgb}{0.1,0.1,0.1}
\lstdefinestyle{matlab}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{LimeGreen}\itshape,
	keywordstyle=\color{RoyalBlue},
	numberstyle=\tiny\color{darkgrey},
	stringstyle=\color{Thistle},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}
\mdfsetup{%
	linecolor=black,
	linewidth=1pt,
	backgroundcolor=blue!5,
	roundcorner=0pt}
\lstset{style=matlab}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
	backgroundcolor=\color{white},
	basicstyle=\ttfamily\footnotesize,
	breaklines=true,
	captionpos=b,
	commentstyle=\color{mygreen},
	keywordstyle=\color{blue},
	stringstyle=\color{mymauve},
	numbers=left,
	numberstyle=\tiny\color{mygray},
	frame=single
}

\begin{document}
	{
		\LARGE
		\textbf{Progress Report 3 - Standard Function and E3nn Studies}
		
	}
		
		\section*{Objective}
		The goal of this project is to numerically determine the parametric coordinates \((\xi, \eta, \zeta)\) of a point within a trilinear hexahedral finite element, given its physical space coordinates \(\mathbf{x}_{\text{phys}} = (x, y, z)\). This process is fundamental in finite element analysis (FEA), where transformations between the reference (parent) domain and the physical domain are essential for interpolation, numerical integration, and applying boundary conditions.
		
		\section*{Understanding the Geometry and Mapping}
		In finite elements, we define elements in a simpler, idealized coordinate system called the \textit{reference domain} or \textit{parent domain}. For 3D hexahedral elements, this domain is the cube \([-1, 1]^3\). Each point \((\xi, \eta, \zeta)\) in this cube can be mapped to a \textit{physical domain}, which represents the actual shape and location of the element in the mesh.
		
		To perform this mapping, we use shape functions based on the trilinear interpolation scheme. Each shape function \(N_i(\xi, \eta, \zeta)\) is associated with a node of the hexahedron and satisfies:
		\begin{itemize}
			\item \(N_i = 1\) at node \(i\)
			\item \(N_i = 0\) at all other nodes
		\end{itemize}
		
		The physical location \(\mathbf{x}(\xi, \eta, \zeta)\) is given by:
		\[
		\mathbf{x}(\xi, \eta, \zeta) = \sum_{i=1}^{8} N_i(\xi, \eta, \zeta) \cdot \mathbf{x}_i
		\]
		
		This is the \textit{forward mapping}. The inverse mapping --- finding \((\xi, \eta, \zeta)\) for a given \(\mathbf{x}_{\text{phys}}\) --- must be done numerically because of the nonlinearity of \(N_i\).
		
		\section*{Shape Functions}
		Each \(N_i\) is a product of linear terms:
		\[
		N_1(\xi, \eta, \zeta) = \frac{1}{8}(1 - \xi)(1 - \eta)(1 - \zeta)
		\]
		with analogous forms for the other 7 nodes.
		
		\section*{Why We Need the Inverse Mapping}
		To evaluate integrals using Gauss quadrature or determine interpolation values at specific physical points, we must express those points in the reference domain. Hence, the inverse mapping is necessary.
		
		\section*{Newton-Raphson Method}
		We define the residual function:
		\[
		\mathbf{r}(\xi, \eta, \zeta) = \mathbf{x}_{\text{phys}} - \mathbf{x}(\xi, \eta, \zeta)
		\]
		and seek its root:
		\[
		\mathbf{r}(\xi, \eta, \zeta) = 0 \quad \Leftrightarrow \quad \mathbf{x}(\xi, \eta, \zeta) = \mathbf{x}_{\text{phys}}
		\]
		
		This nonlinear system is solved using the Newton-Raphson method. At each iteration \(k\):
		\begin{align*}
			\mathbf{x}^{(k)} &= \sum_i N_i(\xi^{(k)}, \eta^{(k)}, \zeta^{(k)}) \cdot \mathbf{x}_i \\
			\mathbf{r}^{(k)} &= \mathbf{x}_{\text{phys}} - \mathbf{x}^{(k)} \\
			\Delta \boldsymbol{\xi} &= J^{-1} \cdot \mathbf{r}^{(k)} \\
			\begin{bmatrix} \xi \\ \eta \\ \zeta \end{bmatrix}^{(k+1)} &= \begin{bmatrix} \xi \\ \eta \\ \zeta \end{bmatrix}^{(k)} + \Delta \boldsymbol{\xi}
		\end{align*}
		
		We repeat until \(\|\mathbf{r}^{(k)}\|\) is sufficiently small.
		
		\section*{Jacobian Matrix}
		The Jacobian matrix \(J\) describes the derivative of the physical coordinates with respect to the parametric coordinates:
		\[
		J = 
		\begin{bmatrix}
			\frac{\partial x}{\partial \xi} & \frac{\partial x}{\partial \eta} & \frac{\partial x}{\partial \zeta} \\
			\frac{\partial y}{\partial \xi} & \frac{\partial y}{\partial \eta} & \frac{\partial y}{\partial \zeta} \\
			\frac{\partial z}{\partial \xi} & \frac{\partial z}{\partial \eta} & \frac{\partial z}{\partial \zeta}
		\end{bmatrix}
		\]
		
		It is computed as:
		\[
		J = \sum_{i=1}^8 \nabla N_i(\xi, \eta, \zeta) \otimes \mathbf{x}_i
		\]
		where \(\nabla N_i = \left[\frac{\partial N_i}{\partial \xi}, \frac{\partial N_i}{\partial \eta}, \frac{\partial N_i}{\partial \zeta} \right]\), and \(\otimes\) is the outer product.
		
		\section*{Implementation Summary}
		\begin{itemize}
			\item \textbf{Step 1: Input validation.} Check shape of input arrays.
			\item \textbf{Step 2: Bounding box check.} Reject points obviously outside the element.
			\item \textbf{Step 3: Newton-Raphson.}
			\begin{itemize}
				\item Initialize \((\xi, \eta, \zeta) = (0, 0, 0)\)
				\item Evaluate shape functions and Jacobian
				\item Update until convergence
			\end{itemize}
			\item \textbf{Step 4: Validate solution.} Ensure final \((\xi, \eta, \zeta) \in [-1, 1]^3\)
		\end{itemize}
		
		\section*{Conceptual Summary}
		\begin{itemize}
			\item The residual \(\mathbf{r} = \mathbf{x}_{\text{phys}} - \mathbf{x}(\xi, \eta, \zeta)\) is driven toward zero.
			\item The Jacobian gives local transformation info.
			\item Convergence depends on the elementâ€™s shape and the initial guess.
		\end{itemize}
		
		This work implements a core capability used throughout finite element software and analysis.
		
	\end{document}
	
	
	\end{document}